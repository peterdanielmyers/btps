<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="initPage()">
    <h1>Bitcoin Node Network Transaction Propagation Simulator</h1>
    <p>v. 0.1</p>
<script>

var myGamePiece;
var myObstacles = [];
var myScore;

var canvasWidth = 1100;
var canvasHeight = 600;
var nodeWidth = 10;
var nodeHeight = 10;
var numNodes = 750;
var numBadNodes = 100;
var numMiningNodes = 10;
var doubleSpendDelay = 50;
var listeningColour = "grey";
var transaction1Colour = "blue";
var transaction2Colour = "red";
var winningMinerColour = "green";
var minConnectionsPerNode = 20;
var maxConnectionsPerNode = 117;
var nodeDistanceThreshhold = 100;
var nodes = [];
var connections = [];
var simulationArea;
var ticker = 0;
var tickDelay = 20;
var distanceDivider = 2;
var globalConnectionAttempts = 0;

const LISTENING = 0;
const TRANSACTION1 = 1;
const TRANSACTION2 = 2;

class Component {
    constructor(width, height, colour, x, y, type) {
        this.type = type;
        this.score = 0;
        this.width = width;
        this.height = height;
        this.speedX = 0;
        this.speedY = 0;
        this.x = x;
        this.y = y;
        //this.update(colour)
    }
    update(colour,strokeColour,miningDot) {
        var ctx = simulationArea.context;
        if (this.type == "text") {
            ctx.font = this.width + " " + this.height;
            ctx.fillStyle = colour;
            ctx.fillText(this.text, this.x, this.y);
        } else if (this.type == "connector") {
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = listeningColour;
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.width, this.height);
            ctx.stroke();
        } else {
            //ctx.fillStyle = color;
            //ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.beginPath();
            ctx.arc(this.x, this.y,this.width/2,0,2*Math.PI,false);
            ctx.fillStyle = colour;
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = strokeColour;
            ctx.stroke();
            if (miningDot) {
                ctx.beginPath();
                ctx.arc(this.x, this.y,this.width/3,0,2*Math.PI,false);
                ctx.fillStyle = "black";
                ctx.fill();
                //ctx.lineWidth = 1;
                //ctx.strokeStyle = "black";
                //ctx.stroke();
            }
        }
    }
}   
class Connection {
    constructor(node1x,node1y,node2x,node2y,distance) {
        this.distance = distance;
        this.sprite = new Component(
            node2x, node2y,
            "grey", node1x, node1y, "connector");
    }
    update() {
        this.sprite.update();
    }
}
class Message {
    constructor(data,distance){
        this.data = data;
        this.distance = distance;
    }
}
class Node {
    constructor(x,y,maxConnections){
        this.x = x;
        this.y = y;
        this.colour = listeningColour;
        this.sprite = new Component(nodeWidth, nodeHeight, listeningColour, this.x, this.y);
        this.maxConnections = maxConnections;
        this.nodes = [];
        this.distances = [];
        this.connections = [];
        this.receivedMessages = [];
        this.winningMiner = false;
        this.bad = false;
        this.mining = false;
        this.status = LISTENING;
    }
    update() {
        var i;
        for (i = 0; i < this.receivedMessages.length; i++) {
            this.receivedMessages[i].distance -= 1;
            //document.getElementById('distanceDisplay').innerHTML = this.receivedMessages[i].distance.toString();
            if (this.receivedMessages[i].distance < 1) {
                this.status = this.receivedMessages[i].data;
                globalConnectionAttempts -= this.receivedMessages.length;
                this.receivedMessages.length = 0;
            }
        }
        var strokeColour = listeningColour;
        if (this.bad) {
            strokeColour = "black";
        }
        switch (this.status) {
          case TRANSACTION1:
            for (i = 0; i < this.nodes.length; i++) {
                this.nodes[i].receive(TRANSACTION1,this.distances[i]);
            }
            this.sprite.update(transaction1Colour,strokeColour,this.mining);
            break;
          case TRANSACTION2:
            for (i = 0; i < this.nodes.length; i++) {
                this.nodes[i].receive(TRANSACTION2,this.distances[i]);
            }
            this.sprite.update(transaction2Colour,strokeColour,this.mining);
            break;
          default:
            this.sprite.update(listeningColour,strokeColour,this.mining);
        }
        if (this.winningMiner) {
            var ctx = simulationArea.context;
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = winningMinerColour;
            ctx.rect(this.x-nodeWidth,this.y-nodeHeight,nodeWidth*2,nodeHeight*2);
            ctx.stroke();
        }
    }
    receive(transaction,distance) {
        if (this.status == LISTENING) {
            if (this.bad && transaction == TRANSACTION1) {
            } else {
                this.receivedMessages.push(new Message(transaction,distance/distanceDivider));
                globalConnectionAttempts++;
            }
        }
    }
    connect(n,d,c) {
        if (!this.nodes.includes(n)) {
            this.nodes.push(n)
            this.distances.push(d)
            this.connections.push(c)
        }
    }
}
class SimulationArea {
    constructor() {
        this.canvas = document.createElement("canvas");
    }
    init() {
        this.canvas.width = parseInt(document.getElementById('canvasWidth').value,10);
        this.canvas.height = parseInt(document.getElementById('canvasHeight').value,10);
        canvasWidth = parseInt(document.getElementById('canvasWidth').value,10);
        canvasHeight = parseInt(document.getElementById('canvasHeight').value,10);
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        
        var i;
        for (i = 0; i < nodes.length; i++) {
            nodes[i].update();
        }
        
        for (i = 0; i < nodes.length; i++) {
            var j;
            for (j = 0; j < nodes.length; j++) {
                var d = nodeDistance(nodes[i],nodes[j]);
                if (d < nodeDistanceThreshhold) {
                    if (nodes[i].connections.length < nodes[i].maxConnections &&
                        nodes[j].connections.length < nodes[j].maxConnections) {
                        connectNodes(nodes[i],nodes[j],d);
                    }
                }
            }
        }
        
        for (i = 0; i < connections.length; i++) {
            connections[i].update();
        }
    }
    start() {
        this.interval = setInterval(updateSimulation, tickDelay);
    }
    stop() {
        clearInterval(this.interval);
    }
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function connectNodes(node1,node2,d) {
    connections.push(new Connection(
        node1.sprite.x, node1.sprite.y,node2.sprite.x,node2.sprite.y,d
    ));
    node1.connect(node2,d,connections[connections.length - 1]);
    node2.connect(node1,d,connections[connections.length - 1]);
}
function createNodes() {
    var i;
    numNodes = parseInt(document.getElementById('numNodes').value,10);
    maxConnectionsPerNode = parseInt(document.getElementById('maxConnectionsPerNode').value,10);
    minConnectionsPerNode = parseInt(document.getElementById('minConnectionsPerNode').value,10);
    nodeIndices = []
    for (i = 0; i < numNodes; i++) {
        nodes.push(new Node(
            Math.floor(Math.random() * (canvasWidth-nodeWidth*2)+nodeWidth),
            Math.floor(Math.random() * (canvasHeight-nodeHeight*2)+nodeHeight),
            randRange(minConnectionsPerNode,maxConnectionsPerNode)
        ));
        nodeIndices.push(i)
    }
    simulationArea.init();
}
function disableButton(btnId) {
    if(btnId){document.getElementById(btnId).disabled = 'true';}
}
function everyinterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}
function getRandomSubarray(arr,size) {
    var shuffled = arr.slice(0), i = arr.length, temp, index;
    while (i--) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(0, size);
}
function initPage() {
    document.getElementById('canvasWidth').value = canvasWidth.toString();
    document.getElementById('numNodes').value = numNodes.toString();
    document.getElementById('numBadNodes').value = numBadNodes.toString();
    document.getElementById('maxConnectionsPerNode').value = maxConnectionsPerNode.toString();
    document.getElementById('minConnectionsPerNode').value = minConnectionsPerNode.toString();
    document.getElementById('canvasHeight').value = canvasHeight.toString();
    document.getElementById('numMiningNodes').value = numMiningNodes.toString();
    document.getElementById('nodeDistanceThreshhold').value = nodeDistanceThreshhold.toString();
    document.getElementById('doubleSpendDelay').value = doubleSpendDelay.toString();
}
function initSimulation() {
    simulationArea = new SimulationArea();
    simulationArea.init();
}
function nodeDistance(node1,node2) {
    x = node2.sprite.x - node1.sprite.x;
    y = node2.sprite.y - node1.sprite.y;
    return Math.sqrt(Math.pow(x,2) + Math.pow(y,2));
}
function randRange(min,max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function setBadNodes() {
    numBadNodes = parseInt(document.getElementById('numBadNodes').value,10);
    badNodes = getRandomSubarray(nodeIndices,numBadNodes);
    for (i = 0; i < numBadNodes; i++) {
        nodes[badNodes[i]].bad = true;
    }
    updateSimulationArea();
}
function setMiningNodes() {
    numMiningNodes = parseInt(document.getElementById('numMiningNodes').value,10);
    miningNodes = getRandomSubarray(nodeIndices,numMiningNodes);
    for (i = 0; i < numMiningNodes; i++) {
        nodes[miningNodes[i]].mining = true;
    }
    updateSimulationArea();
}    
function startSimulation(id) {
    disableButton(id);
    simulationArea.start();
}
function stopSimulation(id) {
    disableButton(id);
    simulationArea.stop();
}
function updateSimulation() {
    ticker++;
    if (ticker==doubleSpendDelay){startTransaction(TRANSACTION2);}
    document.getElementById('tickerDisplay').innerHTML = ticker.toString();
    document.getElementById('globalConnectionAttempts').innerHTML = globalConnectionAttempts.toString();
    if (globalConnectionAttempts < 1) {
        stopSimulation();
        document.getElementById('globalConnectionAttempts').innerHTML = 'Transaction Propagation Simulation Complete';
        var successfulMiner = Math.floor(Math.random() * (numMiningNodes-1));
        var i;
        var j = 0;
        debugger;
        for (i=0;i<nodes.length;i++) {
            if (nodes[i].mining) {
                if (j==successfulMiner) {
                    nodes[i].winningMiner = true;
                    document.getElementById('globalConnectionAttempts').innerHTML = 'Transaction Propagation Simulation Complete';
                    var final_text = '';
                    switch (nodes[i].status) {
                        case LISTENING:
                            final_text = 'had not received the transaction or the double spend transaction.'
                            break;
                        case TRANSACTION1:
                            final_text = 'had received the genuine transaction.'
                            break;
                        case TRANSACTION2:
                            final_text = 'had received the double spend transaction.'
                    }
                    document.getElementById('output').innerHTML = 'The next block is won by a node that '.concat(final_text);
                    break;
                } else {
                    j++;
                }
            }
        }
    }
    updateSimulationArea();
}
function updateSimulationArea() {
    simulationArea.clear();
    simulationArea.frameNo += 1;
    var i;
    for (i = 0; i < connections.length; i++) {
        connections[i].update();
    }
    for (i = 0; i < numNodes; i++) {
        nodes[i].update();
    }
}
function startTransaction(transaction,id) {
    disableButton(id);
    doubleSpendDelay = parseInt(document.getElementById('doubleSpendDelay').value,10);
    var i;
    for (i = 0; i < numNodes; i++) {
        if (nodes[i].status == LISTENING && !nodes[i].bad) {
            nodes[i].status = transaction;
            nodes[i].update();
            break;
        }
    }
}

</script>
<br>
<table>
<form action="/action_page.php">
    <tr>
        <td><label for="fname">Width:</label>
            <input type="text" id="canvasWidth" name="canvasWidth"></td>
        <td><label for="lname">Number of Nodes:</label>
            <input type="text" id="numNodes" name="numNodes"></td>
        <td><label for="lname">Number of Bad Nodes:</label>
            <input type="text" id="numBadNodes" name="numBadNodes"></td>
        <td><label for="lname">Min Connections per Node:</label>
            <input type="text" id="minConnectionsPerNode" name="minConnectionsPerNode"></td>
        <td></td>
    </tr>
    <tr>
        <td><label for="lname">Height:</label>
            <input type="text" id="canvasHeight" name="canvasHeight"></td>
        <td><label for="lname">Double Spend Delay:</label>
            <input type="text" id="doubleSpendDelay" name="doubleSpendDelay"></td>
        <td><label for="lname">Number of Mining Nodes:</label>
            <input type="text" id="numMiningNodes" name="numMiningNodes"></td>
        <td><label for="lname">Max Connections per Node:</label>
            <input type="text" id="maxConnectionsPerNode" name="maxConnectionsPerNode"></td>
        <td><label for="lname">Max Distance Nodes Can Be Connected:</label>
            <input type="text" id="nodeDistanceThreshhold" name="nodeDistanceThreshhold"></td>
    </tr>
</form>
</table>
<button id="initSimulation" onclick="initSimulation(this.id)">1. Init Simulation</button>
<button id="createNodes" onclick="createNodes(this.id)">2. Create Nodes</button>
<button id="setBadNodes" onclick="setBadNodes(this.id)">3. Set Bad Nodes</button>
<button id="setMiningNodes" onclick="setMiningNodes(this.id)">4. Set Mining Nodes</button>
<button id="transaction1Button" onclick="startTransaction(TRANSACTION1,this.id)">5. Set Transaction</button>
<button id="startButton" onclick="startSimulation(this.id)">6. Start Simulation</button>
<button id="stopButton" onclick="stopSimulation(this.id)">7. Stop Simulation</button>
<table>
    <tr><td>Ticks:</td><td id="tickerDisplay"></td><td>Active connection attempts:</td><td id="globalConnectionAttempts"></td></tr>
    <tr><td id="output"></td></tr>
    </table>
    <h2>Usage</h2>
    <ul><li>Set the parameters you want for the simulation.</li>
        <li>Click the buttons in the numbered order.
            <ul><li>Width and Height must be set before pressing 1. Init Simulation.</li>
                <li>Number of Nodes, Min Connections per Node, Max Connections per Node, and Max Distance Nodes Can Be Connected must be set before pressing 2. Create Nodes.</li>
                <li>Number of bad nodes must be set before pressing 3. Set Bad Nodes.</li>
                <li>Number of mining nodes must be set before pressing 4. Set Mining Nodes.</li>
                <li>Double Spend Delay must be set before pressing 6. Start Simulation.</li>
            </ul>
        </li>
        <li>The simulation will stop when complete and choose a miner to win the next block. You can stop the simulation early with button 7.</li>
        <li>(You don't <i>need</i> to set "bad nodes" or "mining nodes".)</li></ul>
    <h2>Known Limitations</h2>
    <p>There are at least two significant limitations to be aware of when using this simulation:</p>
    <ol><li>Currently, nodes are modelled as being roughly equally distributed. The number of connections each node has are randomly chosen, so some nodes will have more connections than others. But, because the parameters are applied pseudo-randomly, nodes are more evenly distributed than they would be in real life. The most significant impact this has is that bad nodes have a much more significant impact in very large networks. In reality, if you were a bad actor creating bad nodes it would be extremely difficult, costly, and perhaps impossible to ensure your bad nodes were so well distributed across the network. So, for large networks, the effects of bad nodes are currently over-emphasised.</li>
        <li>Currently, when a node receives a bad transaction, it is just ignored.</li></ol>
    
    <h2>Understanding Parameters and Variables</h2>
    <h3>Width and Height</h3>
    <p>These are just the width and height of the html canvas object. Nodes are distributed evenly throughout the canvas. So size does matter. If you have lots of nodes, it needs to be bigger otherwise it's hard to see what's happening. If you have few nodes, a large canvas, and a small distance for nodes to connect, then the network won't join up properly.</p>
    <h3>Number of Nodes</h3>
    <p>Estimates of the number of nodes (with rough numbers as at 22 August 2020):</p>
    <ul><li>On BTC (~45,000): <a href="http://luke.dashjr.org/programs/bitcoin/files/charts/software.html">http://luke.dashjr.org/programs/bitcoin/files/charts/software.html</a></li>
        <li>On BCH (~1,260): <a href="https://cash.coin.dance/nodes">https://cash.coin.dance/nodes</a> </li>
        <li>On BSV (~300): <a href="https://sv.coin.dance/nodes">https://sv.coin.dance/nodes</a></li></ul>
    <h3>Number of Bad Nodes</h3>
    <p>"Bad Nodes" are nodes that are complicit with the double spend attack. They are programmed to refuse the original transaction, so will only process the double spend transaction. As noted in the section on limitations, the simulation over emphasises the effects of bad nodes on a large network, because it generously assumes that the attacker is able to control nodes that are well distributed and connected throughtout the network. In reality, for a large network, this is extremely difficult—maybe impossible—to achieve.</p>
    <h3>Min/Max Connections per Node</h3>
    <p>In Bitcoin Core default settings, maximum available connection slots per node are 117, this figure comes from: <a href="https://en.bitcoin.it/wiki/Clearing_Up_Misconceptions_About_Full_Nodes#Very_roughly_estimating_the_total_node_count">https://en.bitcoin.it/wiki/Clearing_Up_Misconceptions_About_Full_Nodes#Very_roughly_estimating_the_total_node_count</a></p>
    <p>People running nodes with poorer internet connection and weaker hardware may restrict the number of connections they make, but I presume they would want a certain number of connections to justify having a node at all. I arbitrarily picked 20 as the default for this figure.</p>
    <h3>Number of Mining Nodes</h3>
    <p>Technically speaking, <i>for every block, there is only <b>one</b> mining node.</i></p>
    <p>This is really, really, really important to understand, and a lot of people don't recognise the implications: for every block, there is only <b>one</b> mining node. This is because mining is a zero-sum game.</p>
    <p>That means that—for every single block—there are <span style="font-family:monospace;">numNodes-1</span> non-mining nodes.</p>
    <p>This simulator only simulates a time span leading up the winning of <i>one</i> block. If you wait until the end of the simulation, it will randomly choose a winning node to generate the next block. This node is the only true "mining node" for that block.</p>
    <p>So, what does "number of mining nodes" mean? <b>It means the number of nodes that are racing to find the hash for the next block.</b> The only relevance that the number of and computing power possessed by these nodes have to the blockchain is that they influence the difficulty of the following block. But, the difficulty of the next block is completely irrelevant to the process of transaction propagation. When transactions are propagating before a block is mined, any node that doesn't win the block will end up being non-mining nodes for that block. Furthermore, the endtire network is "blind" as to which node will actually win the block. Two competing versions of a transaction are therefore like a selfish gene: propagating as far as possible, until ultimately one node—and nobody knows which one—will win a block. Whichever transaction that node has received when it wins the block will be written to the chain.</p>
    <p>Not only does a transaction not know which node will "win", it also doesn't know which nodes are even trying to find a block this time around.</p>
    
    <h2>Background</h2>
    <p>The background to this simulation is Satoshi's post on "The Snack Machine Problem", available here: <a href="https://bitcointalk.org/index.php?topic=423.msg3819#msg3819">https://bitcointalk.org/index.php?topic=423.msg3819#msg3819</a></p>
    <h3>Context</h3>
    <p>Satoshi was responding to a thread where <a href="https://bitcointalk.org/index.php?topic=423.msg3647#msg3647">someone had posed this problem</a> (here quoted in full, but emphasis mine and I have labelled two sentences A and B):</p>
    <p style="margin-left:5%;font-family:monospace;">
        How would a Bitcoin snack  machine work?<br />
        1) You want to walk up to the machine. Send it a bitcoin.<br />
        2) ?<br />
        3) Walk away eating your nice sugary snack. (Profit!)<br />
        <b>You don't want to have to wait an hour for you transaction to be confirmed.</b> (A)<br />
        <b>The vending machine company doesn't want to give away lots of free candy.</b> (B)<br />
        <b>How does step 2 work?</b></p>
    <p>The (false) assumption behind this problem is that <i>Bitcoin transactions are validated by miners</i>. This assumption is evident from sentences A and B.</p>
    <p>If one makes this assumption, then on the surface a Bitcoin snack machine would seem to be impossible, because:</p>
    <ul><li>Sentence A: Blocks are only created every 10 mins, so it could take ages for the transaction to actually be written to the blockchain.</li>
        <li>Sentence B: The vending machine company don't want people walking away with free candy because the vending machine can't validate transactions. So: the machine needs to validate transactions <i>faster than they can be written to the blockchain</i>.</ul>
    <p>If <i>miners</i> validate transactions, then the snack machine doesn't seem possible, hence the original post.</p>
    <h3>Satoshi's Response</h3>
    <p>There was a lot of discussion in response to this post, but I will just skip ahead to Satoshi's answer to this problem. Here's the whole of Satoshi's response (again, all emphasis mine, and I've labelled some sentences):</p>
    <p style="margin-left:5%;font-family:monospace;">
        I believe it'll be possible for a payment processing company to provide as a service the rapid distribution of transactions with <b>good-enough checking in something like 10 seconds or less</b>. (A)<br />
        The <b>network nodes</b> only <b>accept</b> the <b>first version</b> of a transaction they receive to incorporate into the block <b>they're trying to generate</b> (B).  When you broadcast a transaction, if someone else <b>broadcasts a double-spend at the same time</b>, it's <b>a race to propagate to the most nodes first</b> (C).  If one has a slight head start, it'll <b>geometrically spread through the network faster and get most of the nodes</b> (D).<br />
        A rough back-of-the-envelope example: (E)<br />
        1         0<br />
        4         1<br />
        16        4<br />
        64        16<br />
        80%      20%<br />
        So if a double-spend has to wait even a second, it has a huge disadvantage.<br />
        The payment processor <b>has connections with many nodes</b> (F).  When it gets a transaction, <b>it blasts it out, and at the same time monitors the network for double-spends</b> (G).  If it receives a double-spend on any of its many listening nodes, then <b>it alerts that the transaction is bad</b> (H).  A double-spent transaction <b>wouldn't get very far without one of the listeners hearing it</b> (I).  The double-spender would have to wait until the listening phase is over, but by then, the payment processor's broadcast has reached most nodes, or is so far ahead in propagating that the double-spender has no hope of grabbing a significant percentage of the remaining nodes.</p>
    <p>It was this post and this explanation about which Satoshi said his famous "If you don't believe me or don't get it, I don't have time to try to convince you, sorry." You can see that here: <a href="https://bitcointalk.org/index.php?topic=532.msg6306#msg6306">https://bitcointalk.org/index.php?topic=532.msg6306#msg6306</a></p>
    <p>And it is certainly the case that after the block size wars, the point Satoshi made in this post is one of the most misunderstood things about Bitcoin. So, let's examine what he says very carefully:</p>
    <h4>Pre-Blockchain Validation</h4>
    <p><b>Sentence A</b> shows Satoshi is imagining a situation where transactions are validated <b>before they are written to the blockchain</b>:</p>
    <ul><li>He/She/They talk(s) about "checking": so what is the <i>something</i> that is "checking" transactions?</li>
        <li>This checking can be "good enough", implying that it's <i>not as secure</i> as the hash-war process that protects what is written to the blockchain. In the <a href="https://nakamotoinstitute.org/bitcoin/">Bitcoin Whitepaper</a> Satoshi described the chances of an attacker successfully completing a double spend as "vanishingly small as he falls further behind" in the race to find the next block (end of paragraph 5 under §11, or p. 7 of <a href="https://nakamotoinstitute.org/static/docs/bitcoin.pdf">the pdf</a>).</li>
        <li>This checking occurs "in something like 10 seconds or less": meaning it <i>cannot be</i> the mining process that performs the checking, as blocks take 10mins to find.</li></ul>
    <p>So, Satoshi thought that something <i>other than the blockchain</i> would validate the transaction. This validation is: (a) faster than finding a block; (b) less secure than finding a block, but "good enough".</p>
    <p><b>Sentence B</b> shows that Satoshi thought nodes would perform this checking before a block is created:</p>
    <ul><li>He/She/They talk(s) about "network nodes" in the process of "trying to generate" a block.</li>
        <li>These "network nodes" either "accept" a transaction or they don't.</li>
        <li>The <i>basis</i> for accepting a transaction is whether it is the "first version" of the transaction or not.</li></ul>
    <p>So, Satoshi thought that <i>before writing a block to the blockchain</i> nodes would undergo a process of validating transactions by accepting only the first version of transactions they receive, and rejecting different versions they receive after this.</p>
    <h4>Bitcoin's Two Races</h4>
    <p>Satoshi's post imagines that there are at least two races going on within the Bitcoin network. The most famous race is clearly described in the Whitepaper: it is the race for nodes to find the next block.</p>
    <p>But! <b>Sentence C</b> describes the pre-blockchain validation process as "a race to propagate to the most nodes first". This is a different race to the hash-war to find the next block.</p>
    <p>This race is what the above script simulates: the race between a transaction and a double spend to propagate throughout the network of nodes.</p>
    <h2>Changelog</h2>
    <table>
        <tr><td>0.1</td><td>First version</td></tr>
    </table>
</body>
</html>
